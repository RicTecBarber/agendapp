import express, { Application, Request, Response, NextFunction } from "express";
import { Server } from "http";
import { format, parse, parseISO, isAfter, addDays, isBefore, isEqual, addMinutes } from "date-fns";
import { utcToZonedTime } from "date-fns-tz";
import { WebSocketServer } from "ws";
import z from "zod";
import { storage } from "./storage";
import { setupAuth } from "./auth";
import { 
  insertAppointmentSchema, 
  appointmentLookupSchema,
  loyaltyLookupSchema
} from "@shared/schema";

export async function registerRoutes(app: express.Application): Promise<Server> {
  // Set up authentication routes
  setupAuth(app);

  // GET /api/availability/:professionalId/:date - Get availability for a specific day
  app.get("/api/availability/:professionalId/:date", async (req: Request, res: Response) => {
    try {
      const professionalId = parseInt(req.params.professionalId);
      const dateString = req.params.date;
      
      // Parse the date from string, keeping it at midnight (00:00) local time
      const date = parseISO(dateString);
      console.log(`Buscando agendamentos para a data: ${date.toISOString()}`);
      console.log(`Data de busca original: ${date.toString()}`);
      
      // Adjust to search all appointments for that day
      const searchDate = new Date(date);
      console.log(`Data ajustada para busca: ${searchDate.toISOString()}`);
      
      // Limite inferior e superior para busca
      const startOfDay = new Date(searchDate);
      startOfDay.setHours(0, 0, 0, 0);
      
      const endOfDay = new Date(searchDate);
      endOfDay.setHours(23, 59, 59, 999);
      
      console.log(`Buscando agendamentos entre ${startOfDay.toISOString()} e ${endOfDay.toISOString()}`);
      
      // Validar que o profissional existe
      const professional = await storage.getProfessional(professionalId);
      if (!professional) {
        return res.status(404).json({ message: "Professional not found" });
      }
      
      // Buscar configurações da barbearia
      const barbershopSettings = await storage.getBarbershopSettings();
      
      // Verificar se a barbearia está aberta nesse dia da semana
      const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
      if (!barbershopSettings.open_days.includes(dayOfWeek)) {
        return res.status(200).json({ 
          available_slots: [],
          message: "The barbershop is closed on this day",
          barbershop_closed: true
        });
      }
      
      // Buscar a disponibilidade do profissional para esse dia da semana
      const availabilityList = await storage.getAvailabilityByProfessionalId(professionalId);
      const dayAvailability = availabilityList.find(a => a.day_of_week === dayOfWeek);
      
      if (!dayAvailability || !dayAvailability.is_available) {
        return res.status(200).json({ 
          available_slots: [],
          message: "The professional is not available on this day",
          professional_unavailable: true
        });
      }
      
      // Buscar agendamentos existentes para esse dia
      console.log(`Buscando agendamentos para a data ${dateString}`);
      
      // IMPORTANTE: Essa é a função que deve trazer os agendamentos do dia certo!
      const appointments = await storage.getAppointmentsByDate(date);
      
      // Filtrar apenas agendamentos deste profissional e com status ativo
      const professionalAppointments = appointments.filter(a => 
        a.professional_id === professionalId && a.status !== "cancelled"
      );
      
      // Disponibilidade do profissional
      let startTime = parseTime(dayAvailability.start_time);
      let endTime = parseTime(dayAvailability.end_time);
      
      // Adjust the availability to be within the barbershop's hours
      const barbershopOpenTime = parseTime(barbershopSettings.open_time);
      const barbershopCloseTime = parseTime(barbershopSettings.close_time);
      
      // Ensure start time is not earlier than barbershop opening time
      if (startTime.hours < barbershopOpenTime.hours || 
          (startTime.hours === barbershopOpenTime.hours && startTime.minutes < barbershopOpenTime.minutes)) {
        startTime = barbershopOpenTime;
      }
      
      // Ensure end time is not later than barbershop closing time
      if (endTime.hours > barbershopCloseTime.hours || 
          (endTime.hours === barbershopCloseTime.hours && endTime.minutes > barbershopCloseTime.minutes)) {
        endTime = barbershopCloseTime;
      }
      
      // Map para armazenar slots ocupados e seus respectivos appointment IDs
      const occupiedSlots = new Map<string, number[]>();
      
      // Get service details
      const services = await storage.getAllServices();
      
      // Processa cada agendamento para determinar quais slots estão ocupados
      professionalAppointments.forEach(appointment => {
        const appointmentDate = new Date(appointment.appointment_date);
        
        // Usar EXATAMENTE o formato UTC que está no banco de dados
        // Isto garante que 9:00 salvo como 12:00 UTC será MOSTRADO como 12:00
        const appointmentHour = appointmentDate.getUTCHours();
        const appointmentMinute = appointmentDate.getUTCMinutes();
        
        // Buscar o serviço para saber duração
        const service = services.find(s => s.id === appointment.service_id);
        const serviceDuration = service?.duration || 30;
        
        // Formatar hora como HH:MM
        const timeString = `${appointmentHour.toString().padStart(2, '0')}:${appointmentMinute.toString().padStart(2, '0')}`;
        
        // Calcular hora de término
        let endHour = appointmentHour;
        let endMinute = appointmentMinute + serviceDuration;
        
        // Ajustar se cruzar limites de hora
        while (endMinute >= 60) {
          endHour++;
          endMinute -= 60;
        }
        
        // Marcar este slot como ocupado
        if (!occupiedSlots.has(timeString)) {
          occupiedSlots.set(timeString, []);
        }
        occupiedSlots.get(timeString)?.push(appointment.id);
        
        // Se o serviço durar mais que 30 minutos, marcar slots adicionais
        if (serviceDuration > 30) {
          let currentHour = appointmentHour;
          let currentMinute = appointmentMinute;
          
          while (true) {
            // Avançar 30 minutos
            currentMinute += 30;
            if (currentMinute >= 60) {
              currentHour++;
              currentMinute -= 60;
            }
            
            // Verificar se já passou do fim do serviço
            if (currentHour > endHour || (currentHour === endHour && currentMinute >= endMinute)) {
              break;
            }
            
            // Marcar este slot intermediário como ocupado
            const slotString = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
            if (!occupiedSlots.has(slotString)) {
              occupiedSlots.set(slotString, []);
            }
            occupiedSlots.get(slotString)?.push(appointment.id);
          }
        }
      });
      
      // Array de slots disponíveis
      const timeSlots: string[] = [];
      
      // Array para armazenar detalhes completos de cada slot (para debug)
      const slotDetails: any[] = [];
      
      // Criar slots de 30 em 30 minutos entre horário de início e fim
      let currentSlot = new Date(date);
      currentSlot.setHours(startTime.hours, startTime.minutes, 0, 0);
      
      const endDateTime = new Date(date);
      endDateTime.setHours(endTime.hours, endTime.minutes, 0, 0);
      
      // Para cada slot de 30 minutos dentro do horário de disponibilidade
      while (currentSlot < endDateTime) {
        // Formatar o horário como string HH:MM
        const slotTime = format(currentSlot, "HH:mm");
        const slotEnd = addMinutes(currentSlot, 30);
        
        // Verificar se já passou da hora atual
        const isPastTime = isAfter(new Date(), currentSlot);
        
        // Verificar se o slot está ocupado por algum agendamento
        const conflictingAppointments = occupiedSlots.get(slotTime) || [];
        const isOccupied = conflictingAppointments.length > 0;
        
        // Um slot está disponível se não for passado e não estiver ocupado
        const isAvailable = !isPastTime && !isOccupied;
        
        if (isAvailable) {
          timeSlots.push(slotTime);
        }
        
        // Guardar detalhes sobre este slot
        slotDetails.push({
          time: slotTime,
          available: isAvailable,
          is_past: isPastTime,
          conflicts: conflictingAppointments.length > 0 ? conflictingAppointments : null
        });
        
        // Avançar para o próximo slot
        currentSlot = slotEnd;
      }
      
      // Verificação final e resposta
      res.json({ 
        available_slots: timeSlots,
        debug_info: {
          date: date.toISOString().split('T')[0],
          professional_id: professionalId,
          slot_details: slotDetails
        }
      });
    } catch (error) {
      console.error("Error getting availability:", error);
      res.status(500).json({ message: "Failed to fetch availability" });
    }
  });

  return app;
}

// Função auxiliar para converter string de horário (HH:MM) em objeto { hours, minutes }
function parseTime(timeStr: string): { hours: number, minutes: number } {
  const [hoursStr, minutesStr] = timeStr.split(':');
  return {
    hours: parseInt(hoursStr, 10),
    minutes: parseInt(minutesStr, 10)
  };
}